# :christmas_tree: :snake: :sparkles: Maja's Advent of Code 2015 :sparkles: :snake: :christmas_tree:

I first tried solving this in 2018 using C++ (some solutions present), and then after completing [Advent of code 2020](https://github.com/mimikrija/AdventOfCode2020), I decided to try and solve everything in Python.

As always, the goal of this exercise was to improve my coding logic and Python-specific skills.
Here is a summary of what I did and what I learned along the way.

Legend:

:ambulance: - I don't fully understand either the logic or the implementation - HALP!

:hourglass_flowing_sand: - I think this could or should run faster, but I don't know how to optimize it!

:hammer: - Not completely satisfied with solution, but I know how (and plan to) fix it.

Puzzle | Solution(s) | Remarks|
---    |---    |---
[Day 1: Not Quite Lisp](http://adventofcode.com/2015/day/1)                         | [Python](01.py), [C++](cpp_01st_Day.cpp) | first day, first `lambda`
[Day 2: I Was Told There Would Be No Math](http://adventofcode.com/2015/day/2)      | [Python](02.py), [C++](cpp_02nd_Day.cpp) | Straightforward puzzle.
[Day 3: Perfectly Spherical Houses in a Vacuum](http://adventofcode.com/2015/day/3) | [Python](03.py), [C++](cpp_03rd_Day.cpp) | complex numbers are a cool way to solve 2D movement problems in Python!
[Day 4: The Ideal Stocking Stuffer](http://adventofcode.com/2015/day/4)  | [Python](04.py) | :hourglass_flowing_sand: I honestly had no idea how to do this until I figured out "there must be a library for this". Using `hashlib` library to generate MD5 hashlib. I am curious about possible optimizations for this sort of problem - we need to find the lowest positive number, which, joined with our input string has a MD5 hash begining with 5 (part 1) or 6 (part 2) leading zeroes.
[Day 5: Doesn't He Have Intern-Elves For This?](http://adventofcode.com/2015/day/5) | [Python](05.py), [C++](cpp_05th_Day.cpp) | :hammer: Testing if strings satisfy various conditions. Lesson learned: immediatelly return `False` if any of the conditions are not satisfied instead of testing if all of them are satisfied - this was a major speed-up. Come to think of it, I probably should have used `any` for this to make it more Pythonic.
[Day 6: Probably a Fire Hazard](http://adventofcode.com/2015/day/6) | [Python](06.py), [C++](cpp_06th_Day.cpp) | :hourglass_flowing_sand: Turning lights on and off in a 1000 x 1000 grid based on instructions. First part was just on and off so instead of filling an array with zeroes and ones, I used a set to keep track only of lights (coordinates) which are on. In the second part; however, the instructions were changed to mean "change the lights brightness", so I had to keep track of coordinate + brightness, so I used a 1000 x 1000 array. Both implementations are very slow and I am wondering how this could have been done more efficiently.
[Day 7: Some Assembly Required](http://adventofcode.com/2015/day/7) | [Python](07.py), [C++](cpp_07th_Day.cpp) | :ambulance: We get a bunch of instructions and need to figure out the value on wire 'a'. I used [this solution](https://bitbucket.org/JIghtuse/adventofcode/src/0aa3b58dfa221bc7f5dca4628b783d544a54688d/day7/python/part_one.py?at=master&fileviewer=file-view-default) as a reference because I had no idea how to implement depth first search + memoization. I am still not quite sure how and why this works. In the second part, we had to run the same function, but with one of the instructions changed. Since all of the solutions of the original function were already memoized, that didn't work. So to solve that, I added another wrapper around everything so that memoization is redefined each time we call the outer function. Does this make sense? I am also using `eval` to evaluate expressions, it seemed like a relatively elegant solution. I am wondering is it possible to generalize expression generation since we have three (which can be reduced to two) types of instructions. If I tried running the code without memoization it seemed like it won't finish any time soon. How come the C++ solution worked fine without it?
[Day 8: Matchsticks](http://adventofcode.com/2015/day/8)                            | [Python](08.py), [C++](cpp_08th_Day.cpp) | Misusing (?) `repr` and `eval` to figure out the difference between the "literal string length" and "encoded string length".
[Day 9: All in a Single Night](http://adventofcode.com/2015/day/9)                  | [Python](09.py) | [Traveling salesman problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem) - we can use the exact solution (generate all possible permutations of order in which we visit all cities and find the shortest route) if the number of cities (or, in this case, stars) is less than 20 (it is).
[Day 10: Elves Look, Elves Say](http://adventofcode.com/2015/day/10)                 | [Python](10.py)| Conway "say numbers" sequence. Initial implementation was slow due to too much slicing. Using a list of integers instead of strings increased efficiency significantly.
[Day 11: Corporate Policy](http://adventofcode.com/2015/day/11) | [Python](11.py)| :hammer: Passwords again! Honestly I don't know why didn't I apply lessons learned in Day 5 for solving this (maybe because I was writing Python solutions later for the puzzles I had already solved in C++). Anyway, this is something for the to do list.
[Day 12: JSAbacusFramework.io](http://adventofcode.com/2015/day/12)                  | [Python](12.py)| This was pretty easy to solve using `import json` and `is_instance` to check whether a given element is of a certain type. This proved useful in some other puzzles where I needed to use `is_instance` to check variable type.
[Day 13: Knights of the Dinner Table](http://adventofcode.com/2015/day/13) | [Python](13.py)| :hammer: I think this is an enhanced variation of Day 9. Again, I created all possible permutations of seating arrangements and found the best one based on the "happiness score". TODO: fix typos
[Day 14: Reindeer Olympics](http://adventofcode.com/2015/day/14)                     | [Python](14.py)| Pretty straightforward puzzle description (and implementation, I hope).
[Day 15: Science for Hungry People](http://adventofcode.com/2015/day/15)             | [Python](15.py)| Another puzzle where `itertools.permutations` did the trick. I think this is the first one where I used `reduce`, which is used to subsequently apply a function to all elements of a list (think of it as an extension of `sum`, but you can use any operator/function). Just a note here, the holy trinity is: `map`, `reduce`, `filter`.
[Day 16: Aunt Sue](http://adventofcode.com/2015/day/16)                              | [Python](16.py)| Dictionaries, sets, and operators.
[Day 17: No Such Thing as Too Much](http://adventofcode.com/2015/day/17)             | [Python](17.py)| Again `itertools` to the rescue. Introducing `filter` for the first time to get all combinations which use a minimal number of containers.
[Day 18: Like a GIF For Your Yard](http://adventofcode.com/2015/day/18)              | [Python](18.py)| Conway game of life, Christmas lights edition. Unlike in other events, here the grid remains fixed, so I had to limit the coordinates to stay between 0 and `DIMENSIONS`. Using sets to only keep track of lights which are on.
[Day 19: Medicine for Rudolph](http://adventofcode.com/2015/day/19) | [Python](19.py)| :ambulance: Ugh, something to do with [(un)ambiguous grammars](https://en.wikipedia.org/wiki/Ambiguous_grammar). For part 2 I consulted solutions from Reddit because I had no idea how to solve it, and I still don't understand completely why and how it works.
[Day 20: Infinite Elves and Infinite Houses](http://adventofcode.com/2015/day/20)    | [Python](20.py)| The biggest lesson learned here was that instead of incrementing something by one and checking if it is divisible by a number, when dealing with large numbers it makes more sense to step in increments of the desired divisor. In that sense this is similar to [2020 Day 13](http://adventofcode.com/2020/day/13).
[Day 21: RPG Simulator 20XX](http://adventofcode.com/2015/day/21)                    | [Python](21.py)| Again `itertools` for finding all possible combinations of shopping. Used some hackyness (manually added zeroes) to include non-mandatory items (armors and rings). There is no need to "play rounds" to decide the winner, as the attack/damage values are constant per battle.
[Day 22: Wizard Simulator 20XX](http://adventofcode.com/2015/day/22) | [Python](22.py)| :ambulance: Whoa, this one was intense. I implemented my version following one of the solutions on Reddit. It helped me understand the rules and the game play. Besides, this was my first attempt of a BFS (Breadth First Search Algorithm) used to evaluate all possible game outcomes. I would like to understand why BFS is a better choice than DFS (Depth First Search Algorithm) here.
[Day 23: Opening the Turing Lock](http://adventofcode.com/2015/day/23)               | [Python](23.py)| Another straightforward puzzle, I can imagine this was a relief to folks solving 2015 in real time after the previous day.
[Day 24: It Hangs in the Balance](http://adventofcode.com/2015/day/24) | [Python](24.py)| :ambulance: I am not very satisfied with this solution because it searches for the smallest group and assumes that the remainder of the weights will be divisible into groups of same weight. I read on Reddit that this will work, but I can't explain why. Does it have to do with the fact that the inputs are all primes?
[Day 25: Let It Snow](http://adventofcode.com/2015/day/25) | [Python](25.py)| :hourglass_flowing_sand: Generate a code based on a rule. I am very curious to know how this could be sped up. Some sort of recursion + generators maybe?
